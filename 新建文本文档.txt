CREATE OR REPLACE PROCEDURE SFIS1.EXAM_CREATE_LOG_TABLE(
                                              TABLENAME   IN VARCHAR2,
                                              LOG_ID IN VARCHAR2,
                                              EMP_NAME    IN VARCHAR2,
                                              EMP_ROLE   IN VARCHAR2,
                                              API IN VARCHAR2,
                                              RESULT    IN VARCHAR2,
                                              STATE   IN NUMBER) 
  Authid Current_User IS
  SQLW        VARCHAR2(500);
  COUNT_TAB            NUMBER;
BEGIN
   SELECT COUNT(0)  INTO COUNT_TAB FROM user_tables WHERE table_name = TABLENAME;
  IF COUNT_TAB<1 THEN
   EXECUTE IMMEDIATE 'CREATE TABLE '||TABLENAME||' (
        LOG_ID    VARCHAR2(50)        PRIMARY KEY,
        EMP_NAME  VARCHAR2(30)     NOT NULL,
        EMP_ROLE  VARCHAR2(30)      NOT NULL,
        API  VARCHAR2(50)                NOT NULL,
        RESULT   VARCHAR2(5000)       NOT NULL,
        STATE     NUMBER                  NOT NULL,
        ACTTIME      DATE                  NOT NULL
    )';
     commit;
  END IF;
 EXECUTE IMMEDIATE  'INSERT INTO '||TABLENAME||' (LOG_ID,EMP_NAME,EMP_ROLE,API,RESULT,STATE,ACTTIME) VALUES(:1,:2,:3,:4,:5,:6,:7)'
 using  LOG_ID,EMP_NAME,EMP_ROLE,API,RESULT,STATE,SYSDATE;
 commit;
END;






down vote
favorite
When I am trying to deserialize my JSON with JSON.Net it gives me invalid values for JSON arrays.

I have simple JSON:

[
{
    "PhaseName": "Start",
    "Advices": ["Lorem ipsum dolor",
    "Lorem ipsum dolor",
    "Lorem ipsum dolor"]
},
{
    "PhaseName": "In Progress",
    "Advices": ["Lorem ipsum dolor",
    "Lorem ipsum dolor",
    "Lorem ipsum dolor"]
},
{
    "PhaseName": "Finish",
    "Advices": ["Lorem ipsum dolor",
    "Lorem ipsum dolor",
    "Lorem ipsum dolor"]
}
]

And a correspondent class in my code:

public class Advices
{
    public string PhaseName { get; set; }
    public List<string> AdvicesList { get; set; }
}
And a veriable that represents an array of Advices objects:

public class MyAdvices
{
    private Advices[] MyAdvicesArrays;
....
So when I am trying to deserialize my JSON like that:

MyAdvicesArrays= JsonConvert.DeserializeObject<Advices[]>(sMyJSON));


2. 如果JSON中含有转义字符，则需要转义。例如文件路径中需要使用"\\"而不是"\"。例如：{ "file":"C:\\a.txt"}。
.NET操作JSON
原始方式：自己按照JSON的语法格式，写代码直接操作JSON字符串。如非必要，应该很少人会走这条路，从头再来的。
JSON文件读入到内存中就是字符串，.NET操作JSON就是生成与解析JSON字符串。.NET操作JSON通常有以下几种方式：
主要类
命名空间
限制
内建LINQ支持
DataContractJsonSerializer    System.Runtime.Serialization.Json    通用    否    
JavaScriptSerializer    System.Web.Script.Serialization    只能在Web环境使用    否    
JsonArray、JsonObject、JsonValue    System.Json    只能在Silverlight中使用    是    
JsonConvert、JArray、JObject、JValue、JProperty    Newtonsoft.Json    通用    是    
2. 通用方式【★★★★★】：
这种方式是使用开源的类库Newtonsoft.Json(下载地址http://json.codeplex.com/)。下载后加入工程就能用。通常可以使用JObject, JsonReader, JsonWriter处理。这种方式最通用，也最灵活，可以随时修改不爽的地方。
(1)使用JsonReader读Json字符串：
string jsonText = @"{""input"" : ""value"", ""output"" : ""result""}";
JsonReader reader = new JsonTextReader(new StringReader(jsonText));
while (reader.Read())
{
    Console.WriteLine(reader.TokenType + "\t\t" + reader.ValueType + "\t\t" + reader.Value);
}
(2)使用JsonWriter写字符串：
StringWriter sw = new StringWriter();
JsonWriter writer = new JsonTextWriter(sw);
writer.WriteStartObject();
writer.WritePropertyName("input");
writer.WriteValue("value");
writer.WritePropertyName("output");
writer.WriteValue("result");
writer.WriteEndObject();
writer.Flush();
string jsonText = sw.GetStringBuilder().ToString();
Console.WriteLine(jsonText);
 (3)使用JObject读写字符串：
JObject jo = JObject.Parse(jsonText);
string[] values = jo.Properties().Select(item => item.Value.ToString()).ToArray();
(4)使用JsonSerializer读写对象(基于JsonWriter与JsonReader): 
/*---数组型数据---*/
string jsonArrayText1 = "[{'a':'a1','b':'b1'},{'a':'a2','b':'b2'}]";
JArray ja = (JArray)JsonConvert.DeserializeObject(jsonArrayText1);
string ja1a = ja[1]["a"].ToString();
//或者
JObject o = (JObject)ja[1];
string oa = o["a"].ToString();
/*---嵌套格式---*/
string jsonText = "{\"beijing\":{\"zone\":\"海淀\",\"zone_en\":\"haidian\"}}";
JObject jo = (JObject)JsonConvert.DeserializeObject(jsonText);
string zone = jo["beijing"]["zone"].ToString();
string zone_en = jo["beijing"]["zone_en"].ToString();
/*---自定义类Project---*/
Project p = new Project() { Input = "stone", Output = "gold" };
JsonSerializer serializer = new JsonSerializer();
StringWriter sw = new StringWriter();
serializer.Serialize(new JsonTextWriter(sw), p);
Console.WriteLine(sw.GetStringBuilder().ToString());
StringReader sr = new StringReader(@"{""Input"":""stone"", ""Output"":""gold""}");
Project p1 = (Project)serializer.Deserialize(new JsonTextReader(sr), typeof(Project));
Console.WriteLine(p1.Input + "=>" + p1.Output);
上面的代码都是基于下面这个Project类定义：
class Project
{
    public string Input { get; set; }
    public string Output { get; set; }
}
3. 内置方式：使用.NET Framework 3.5/4.0中提供的System.Web.Script.Serialization命名空间下的JavaScriptSerializer类进行对象的序列化与反序列化，很直接。
Project p = new Project() { Input = "stone", Output = "gold" };
 JavaScriptSerializer serializer = new JavaScriptSerializer();
 var json = serializer.Serialize(p);
 Console.WriteLine(json);
 var p1 = serializer.Deserialize<Project>(json);
 Console.WriteLine(p1.Input + "=>" + p1.Output);
 Console.WriteLine(ReferenceEquals(p,p1));
注意：如果使用的是VS2010，则要求当前的工程的Target Framework要改成.Net Framework 4，不能使用Client Profile。当然这个System.Web.Extensions.dll主要是Web使用的，直接在Console工程中用感觉有点浪费资源。
　　此外，从最后一句也可以看到，序列化与反序列化是深拷贝的一种典型的实现方式。
4. 契约方式：使用System.Runtime.Serialization.dll提供的DataContractJsonSerializer或者 JsonReaderWriterFactory实现。
Project p = new Project() { Input = "stone", Output = "gold" };
DataContractJsonSerializer serializer = new DataContractJsonSerializer(p.GetType());
string jsonText;
using (MemoryStream stream = new MemoryStream())
{
    serializer.WriteObject(stream, p);
    jsonText = Encoding.UTF8.GetString(stream.ToArray());
    Console.WriteLine(jsonText);
}
using (MemoryStream ms = new MemoryStream(Encoding.UTF8.GetBytes(jsonText)))
{
    DataContractJsonSerializer serializer1 = new DataContractJsonSerializer(typeof(Project));
    Project p1 = (Project)serializer1.ReadObject(ms);
    Console.WriteLine(p1.Input + "=>" + p1.Output);
}
这里要注意，这里的Project类和成员要加相关的Attribute：
[DataContract]
class Project
{
    [DataMember]
    public string Input { get; set; }
    [DataMember]
    public string Output { get; set; }
}


Git筆記

因此，多人协作的工作模式通常是这样：
1.	首先，可以试图用git push origin branch-name推送自己的修改；
2.	如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；
3.	如果合并有冲突，则解决冲突，并在本地提交；
4.	没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！
如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。
这就是多人协作的工作模式，一旦熟悉了，就非常简单。
小结
•	查看远程库信息，使用git remote -v；
•	本地新建的分支如果不推送到远程，对其他人就是不可见的；
•	从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；
•	在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；
•	建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；
•	从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。


git init --help
建本地裸倉庫
git init --bare

git clone file:///C:/local

git push origin

git pull

echo "# Code" >> README.md
  git init
  git add README.md
  git commit -m "first commit"
  git remote add origin https://github.com/CTLtomato/Code.git
  git push -u origin master

git remote add origin git@github.com:CTLtomato/Code.git

git push -u origin master

配置代理服務器(在需要代理賬號訪問外網時，設置了才能從GitHub clone別人的代碼，否則報git clone出錯：443)
                          賬號 : 密碼  代理服務器IP地址 端口
git config --global http.proxy F2843942:27WJaVaY@10.191.131.2:3128

git clone https://github.com/less/less.js.git





















https://FIHSER-GYv07.fih.gd/svn/WeCharSendMessage/









FTP
git clone git@114.215.140.253:/home/git/auto601.git



$ git clone http[s]://example.com/path/to/repo.git/
$ git clone ssh://example.com/path/to/repo.git/
$ git clone git://example.com/path/to/repo.git/
$ git clone /opt/git/project.git 
$ git clone file:///opt/git/project.git
$ git clone ftp[s]://example.com/path/to/repo.git/
$ git clone rsync://example.com/path/to/repo.git/
